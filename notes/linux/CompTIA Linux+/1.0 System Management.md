# 1.0 System Management

## 1.1 Summarize Linux fundamentals.

### 1.1.1 Filesystem Hierarchy Standard (FHS)

- **`/boot`**: Contains files related to the boot loader, such as the Linux kernel, initial RAM disk, and bootloader configuration files.

  - **What is the purpose of the `/boot` directory in Linux?**
    - The `/boot` directory contains files necessary for the booting process of the Linux system, such as the Linux kernel, initial RAM disk (initrd or initramfs), and bootloader configuration files.
  - **What files would you typically find in the `/boot` directory?**
    - You would typically find the Linux kernel image (`vmlinuz`), initial RAM disk image (`initrd` or `initramfs`), and bootloader configuration files (such as `grub.cfg` for GRUB bootloader) in the `/boot` directory.
      ```bash
      [isma@razer boot]$ ls
      EFI  grub  initramfs-linux-fallback.img  initramfs-linux.img  intel-ucode.img  vmlinuz-linux
      ```

- **`/proc`**: A virtual filesystem providing process and kernel information as files. For example, `/proc/cpuinfo` contains information about the CPU.

  ```bash
  [isma@razer proc]$ ls
  1      109   1422  1519  1725  18    202   2127  2449  31    37    4588  574   69    779   87    9012  9561        cpuinfo        key-users     schedstat      zoneinfo
  100    11    1431  1542  1727  181   21    22    2475  3138  375   46    59    70    78    88    9037  9571        crypto         keys          scsi
  10023  110   1436  1557  173   1817  2111  23    25    32    38    4607  6     7159  780   8801  9038  96          devices        kmsg          self
  1005   111   1437  1567  1740  182   2112  2311  2594  3223  384   47    60    7188  781   8814  9039  962         diskstats      kpagecgroup   slabinfo
  10052  112   1456  16    1741  1828  2113  236   26    3252  385   478   61    7198  782   89    91    9673        dma            kpagecount    softirqs
  101    13    1460  1600  1749  1849  2114  2368  2604  3256  386   48    619   72    783   8907  92    97          driver         kpageflags    stat
  10129  1365  1463  1601  175   1870  2115  2385  2614  3266  39    483   62    73    784   8912  923   9885        dynamic_debug  loadavg       swaps
  102    1367  1477  1602  1750  19    2116  2389  2623  3292  4     49    623   74    785   8921  9244  99          execdomains    locks         sys
  10217  1378  1480  1603  1753  1901  2117  2390  2643  3293  4074  5     626   7452  786   8938  93    acpi        fb             meminfo       sysrq-trigger
  10372  1393  1484  1604  176   1916  2118  2392  2652  33    41    50    63    7479  8     8941  9301  asound      filesystems    misc          sysvipc
  10389  14    1495  163   1767  1917  2120  2394  2661  334   4103  51    6307  75    80    8942  9318  bootconfig  fs             modules       thread-self
  1044   1408  15    1650  177   1919  2121  24    27    338   4123  53    6495  76    8170  8944  936   buddyinfo   interrupts     mounts        timer_list
  10459  1409  150   1653  1773  1958  2122  2400  2707  339   42    54    6496  77    825   8959  94    bus         iomem          mtrr          tty
  10548  1413  1502  1682  1775  1990  2123  2401  2765  340   43    55    65    772   8468  8974  941   cgroups     ioports        net           uptime
  10652  1416  1509  169   178   2     2124  2403  29    345   431   56    66    776   85    8979  944   cmdline     irq            pagetypeinfo  version
  10673  1420  1516  17    179   20    2125  2435  3     35    44    57    67    777   86    9     9491  config.gz   kallsyms       partitions    vmallocinfo
  10701  1421  1518  170   1798  2000  2126  2438  30    36    45    573   68    778   8637  90    95    consoles    kcore          pressure      vmstat
  ```

  - **What is the `/proc` directory used for in Linux?**
    - The `/proc` directory is a virtual filesystem that provides information about system processes and the kernel in real-time. It contains various files and directories that represent the current state of the system.
  - **How would you use the `/proc` directory to find information about the CPU?**
    - You can find information about the CPU by accessing the `/proc/cpuinfo` file. For example, using the command `cat /proc/cpuinfo` will display detailed information about the CPU(s) in the system. This includes information such as the processor type, vendor ID, CPU family, model, model name, stepping, microcode, CPU MHz, cache size, and more.
    - The `/proc` directory contains several other important files and directories, such as:
      - `/proc/meminfo`: Provides information about the system's memory usage, including total and available memory.
      - `/proc/uptime`: Shows the system's uptime and the amount of time it has been idle.
      - `/proc/loadavg`: Displays the system load averages.
      - `/proc/partitions`: Lists the partitions recognized by the kernel.
      - `/proc/net/`: Contains network-related information and statistics.
      - `/proc/version`: Displays the Linux kernel version and build information.
      - `/proc/filesystems`: Lists the filesystems supported by the kernel.
      - `/proc/mounts`: Provides information about mounted filesystems.
      - `/proc/sys/`: Contains kernel parameters that can be read and modified at runtime.

- **`/sys`**: A virtual filesystem containing information and configuration about the system hardware. It provides a unified way to access and manage hardware devices.

  ```bash
  [isma@razer sys]$ ls
  block  bus  class  dev  devices  firmware  fs  hypervisor  kernel  module  power
  ```

  - **What is the purpose of the `/sys` directory in Linux?**
    - The `/sys` directory is a virtual filesystem that provides information and configuration options for system hardware. It allows interaction with hardware devices through a unified interface.
  - **How is `/sys` different from `/proc`?**
    - While both `/sys` and `/proc` are virtual filesystems, `/proc` is primarily focused on process and kernel information, whereas `/sys` provides a structured way to access and manage hardware devices and their configurations.
  - **How is `/sys` different from `/proc/sys`?**
    - The `/sys` directory provides a structured way to access and manage hardware devices and their configurations. It is primarily focused on hardware information and configuration.
    - The `/proc/sys` directory is a part of the `/proc` filesystem and contains kernel parameters that can be read and modified at runtime. These parameters control various aspects of kernel and system behavior.
    - In summary, `/sys` is focused on hardware management and configuration, while `/proc/sys` deals with kernel parameters and system settings.

- **`/var`**: Contains variable data files that are expected to grow in size, such as logs, mail, and spool directories.

  - **What type of data is stored in the `/var` directory?**
    - The `/var` directory stores variable data files that change frequently and are expected to grow in size, such as system logs, mail, print spool files, and temporary files.
      ```bash
      [isma@razer var]$ ls
      cache  db  empty  games  lib  local  lock  log  mail  named  opt  run  spool  tmp
      ```
  - **Why is it important to monitor the `/var` directory?**
    - It is important to monitor the `/var` directory because it can grow significantly over time, potentially consuming disk space and affecting system performance. Monitoring helps in managing disk usage and ensuring system stability.

- **`/usr`**: Contains user-installed software and libraries. It includes subdirectories like `/usr/bin` for user binaries and `/usr/lib` for libraries.

  - **What is stored in the `/usr` directory?**
    - The `/usr` directory contains user-installed software, libraries, documentation, and other shared resources. It includes subdirectories like `/usr/bin` for executable binaries, `/usr/lib` for libraries, and `/usr/share` for shared data.
      ```bash
      [isma@razer usr]$ ls
      bin  include  lib  lib32  lib64  local  sbin  share  src
      ```
  - **What is the difference between `/usr/bin` and `/bin`?**
    - `/bin` contains essential command binaries needed for system booting and single-user mode, while `/usr/bin` contains the majority of user command binaries that are not required for booting or minimal system repair.

- **`/lib`**: Contains essential shared libraries and kernel modules required by the system’s binaries.

  - **What is the purpose of the `/lib` directory?**
    - The `/lib` directory contains essential shared libraries and kernel modules that are required by the system’s binaries to run properly.
  - **How is `/lib` different from `/usr/lib`?**
    - `/lib` contains libraries essential for the basic functioning of the system and needed for booting, whereas `/usr/lib` contains libraries for user-installed applications and software.

- **`/dev`**: Contains device files, which represent hardware devices and peripherals, such as `/dev/sda` for a hard drive.

  - **What type of files are found in the `/dev` directory?**
    - The `/dev` directory contains device files that represent hardware devices and peripherals. These files provide an interface to interact with hardware components.
  - **Can you give an example of a device file and its purpose?**
    - An example is `/dev/nvme0n1`, which represents the first NVMe storage device. It allows programs to read from and write to the NVMe drive by interacting with this device file.

- **`/etc`**: Contains system-wide configuration files and scripts that control the system's operation.

  - **What is stored in the `/etc` directory?**
    - The `/etc` directory contains system-wide configuration files and scripts that control the system's operation and behavior. This includes configuration files for the system, applications, and services.
  - **Why is the `/etc` directory important for system administration?**
    - The `/etc` directory is crucial for system administration because it holds the configuration files that determine the behavior of the system and services. Changes to these files can impact the entire system's operation.

- **`/opt`**: Used for installing optional software packages. Each package can have its own subdirectory in `/opt`.

  ```bash
  [isma@razer opt]$ ls
  asdf-vm  brave-bin  containerd  discord  google  microsoft  postman  spotify  ventoy  visual-studio-code  zoom
  ```

  - **What is the purpose of the `/opt` directory?**
    - The `/opt` directory is used for installing optional software packages that are not part of the default distribution. Each package can have its own subdirectory within `/opt`.
  - **How does `/opt` differ from `/usr/local`?**
    - `/opt` is used for third-party software that is not managed by the system's package manager, while `/usr/local` is typically used for software installed manually by the system administrator, often from source code.

- **`/bin`**: Contains essential command binaries that need to be available in single-user mode and for all users, such as `ls`, `cp`, and `mv`.

  - **What type of binaries are found in the `/bin` directory?**
    - The `/bin` directory contains essential command binaries that are required for the system to boot and run in single-user mode. These commands are available to all users.
  - **Why is `/bin` separate from `/usr/bin`?**
    - `/bin` contains essential commands needed for system recovery and booting, which must be available even if `/usr` is not mounted. `/usr/bin` contains additional user binaries that are not critical for booting.

- **`/sbin`**: Contains essential system binaries, typically used for system administration, such as `ifconfig`, `reboot`, and `fdisk`.

  - **What is the purpose of the `/sbin` directory?**
    - The `/sbin` directory contains essential system binaries used for system administration tasks. These binaries are typically used by the root user for managing the system.
  - **Who typically uses the binaries in `/sbin`?**
    - The binaries in `/sbin` are typically used by the system administrator (root user) for performing system management tasks such as configuring network interfaces, managing disks, and rebooting the system.

- **`/home`**: Contains the home directories for all users, where they store their personal files and settings.

  - **What is stored in the `/home` directory?**
    - The `/home` directory contains the personal directories for all users. Each user has a subdirectory within `/home` where they store their personal files, settings, and configurations.
  - **Why is the `/home` directory important for users?**
    - The `/home` directory is important for users because it provides a dedicated space for them to store their personal files and configurations, ensuring that each user's data is kept separate and secure.

- **`/media`**: A mount point for removable media such as USB drives and CDs. Subdirectories within `/media` are created as needed for each device.

  - **What is the purpose of the `/media` directory?**
    - The `/media` directory is traditionally used as a mount point for removable media such as USB drives, CDs, and other external storage devices. It provides a standard location for accessing these devices. However, in some distributions like Arch Linux, the default mount point may be different.
  - **How does the system use the `/media` directory when a USB drive is connected?**
    - On many Linux distributions, when a USB drive is connected, the system automatically creates a subdirectory within `/media` for the device, making it accessible to the user. The device can then be mounted and accessed through this subdirectory.
  - **What is the default mount point for removable media in Arch Linux?**
    - In Arch Linux, the default mount point for removable media is typically `/run/media/username/`. When a USB drive is connected, a subdirectory within `/run/media/username/` is created for the device, making it accessible to the user.

- **`/mnt`**: A generic mount point for temporarily mounting filesystems. It is often used for mounting external devices or other filesystems temporarily.

  - **What is the `/mnt` directory used for?**
    - The `/mnt` directory is a generic mount point used for temporarily mounting filesystems. It is often used by system administrators for manually mounting external devices or filesystems for short-term use.
  - **How is `/mnt` different from `/media`?**
    - While both `/mnt` and `/media` are used for mounting filesystems, `/media` is typically used for automatically mounting removable media with subdirectories created as needed, whereas `/mnt` is used for manually mounting filesystems temporarily.

- **`/root`**: The home directory for the root user. It is separate from `/home` to maintain security and integrity.

  ```
  [root@razer root]# ls
  Desktop  Documents  Downloads  Music  Pictures	Public	Templates  Videos
  ```

  - **What is the purpose of the `/root` directory?**
    - The `/root` directory is the home directory for the root user. It is kept separate from `/home` to maintain the security and integrity of the root user's files and settings.
  - **Why is the root user's home directory separate from other users' home directories?**
    - The root user's home directory is separate from other users' home directories to ensure that the root user's files and configurations are secure and not affected by regular user activities.

- **`/tmp`**: Contains temporary files created by system processes and users. Files in `/tmp` are typically deleted upon system reboot.

  - **What type of files are stored in the `/tmp` directory?**
    - The `/tmp` directory stores temporary files created by system processes and users. These files are usually needed only for a short duration and are typically deleted upon system reboot.
  - **Why is it important to manage the `/tmp` directory?**
    - It is important to manage the `/tmp` directory to prevent it from consuming excessive disk space, which can affect system performance. Regular cleanup of `/tmp` ensures efficient use of disk space.
  - **How is `/tmp` different from `/var`?**
    - The `/tmp` directory is intended for temporary files that are only needed for a short duration, and it is often cleared upon system reboot. It is used for transient data that does not need to persist between reboots.
    - The `/var` directory, on the other hand, contains variable data files that are expected to grow in size and persist between reboots. This includes logs, mail spools, print queues, and other data that needs to be retained for longer periods. The data in `/var` is more permanent compared to the transient nature of the data in `/tmp`.

### 1.1.2 Basic boot process

The basic boot process is the sequence of steps that a computer system goes through from powering on to loading the operating system and reaching the user login prompt.

- **Basic input/output system (BIOS)**: BIOS is firmware that initializes and tests hardware components during the boot process and provides runtime services for operating systems and programs. It performs the Power-On Self Test (POST), which is a diagnostic testing sequence to ensure hardware is functioning correctly, initializes system devices, and loads the bootloader, which is a program responsible for loading the operating system from the bootable device.

  - **What is the role of BIOS in the boot process?**
    - BIOS initializes hardware components, performs POST (Power-On Self Test), and loads the bootloader from the bootable device.
  - **What happens during the Power-On Self Test (POST)?**
    - During POST, the BIOS runs a series of diagnostic tests to ensure that the essential hardware components such as the CPU, RAM, and disk controllers are functioning correctly.
  - **Can BIOS be updated, and if so, how?**
    - Yes, BIOS can be updated through a process known as "flashing." This involves using a special utility provided by the motherboard manufacturer to write a new BIOS firmware version to the BIOS chip.

- **Unified Extensible Firmware Interface (UEFI)**: UEFI is a modern firmware interface that provides more advanced features compared to BIOS, such as support for large drives (over 2TB), faster boot times, secure boot, and a more user-friendly graphical interface.

  - **What is UEFI and how does it improve upon BIOS?**
    - UEFI is a modern firmware interface that provides advanced features compared to BIOS, such as support for large drives, faster boot times, secure boot, and a more user-friendly graphical interface.
  - **What is the purpose of secure boot in UEFI?**
    - Secure boot ensures only trusted software is loaded during the boot process by verifying the digital signatures of the bootloader and kernel.
  - **How does BIOS differ from UEFI?**
    - BIOS uses a Master Boot Record (MBR), which is a special type of boot sector at the beginning of storage devices that contains information on how the logical partitions, containing file systems, are organized and includes the boot loader, for booting and has a simpler interface. Whereas UEFI supports larger hard drives, has faster boot times, and includes more features like secure boot and a graphical interface.

- **`vmlinuz`**: `vmlinuz` is the compressed Linux kernel executable that is loaded into memory by the bootloader and decompressed to start the Linux operating system.

  - **Why is the Linux kernel compressed as `vmlinuz`?**
    - The Linux kernel is compressed as `vmlinuz` to save space and reduce the time it takes to load the kernel into memory during the boot process. The compression allows for faster boot times and efficient use of storage space.
  - **How does the bootloader handle `vmlinuz` during the boot process?**
    - During the boot process, the bootloader loads the `vmlinuz` file into memory and then decompresses it to start the Linux kernel. This involves initializing the kernel and passing control to it so that it can begin managing system resources and hardware interactions.
    - **What is the difference between `vmlinux` and `vmlinuz`?**
      - `vmlinux` is the uncompressed, raw Linux kernel executable, whereas `vmlinuz` is the compressed version of the Linux kernel. The compression in `vmlinuz` reduces the size of the kernel for faster loading during the boot process, while `vmlinux` is used primarily for debugging and development purposes.

- **Grand Unified Bootloader version 2 (GRUB2)**: GRUB2 is the default bootloader for most Linux distributions. It is responsible for loading and transferring control to the operating system kernel.

  - **How can you update the GRUB2 configuration?**
    - You can update the GRUB2 configuration by running the `grub2-mkconfig` command to generate a new `grub.cfg` file based on the current system configuration and available kernels.
  - **What is the difference between GRUB2 and the original GRUB?**
    - GRUB2 offers more advanced features compared to the original GRUB, including support for modern partitioning schemes like GPT, more flexible configuration, scripting support, and better compatibility with diverse filesystems. GRUB2 also has an improved graphical interface and modular architecture, making it more versatile and easier to customize.

- **Boot sources**: Boot sources are devices or media from which the system can boot, such as hard drives, USB drives, CDs/DVDs, and network interfaces.

  - **What are boot sources and how are they configured?**
    - Boot sources are devices or media from which the system can boot, such as hard drives, USB drives, CDs/DVDs, and network interfaces. They are configured in the BIOS/UEFI settings.
  - **How do you change the boot order in BIOS/UEFI?**
    - To change the boot order, you need to enter the BIOS/UEFI setup during system startup (usually by pressing a key like F2, F10, Del, or Esc), navigate to the boot menu, and then adjust the boot order by prioritizing the desired boot sources.
  - **What is a network boot (PXE), and how does it work as a boot source?**
    - Network boot, or Preboot eXecution Environment (PXE), allows a computer to boot from a network server instead of local storage. During a PXE boot, the system retrieves boot files over a network connection, enabling tasks such as remote installations and diskless booting.
  - **Can you explain the difference between booting from a USB drive and booting from an ISO image?**
    - Booting from a USB drive involves using a bootable USB flash drive with an operating system installed on it. Booting from an ISO image involves creating a bootable CD/DVD or USB drive from an ISO file, which is an exact copy of an entire optical disc. Both methods allow the system to start from external media, but an ISO image needs to be written to a physical medium first.

- **Preboot eXecution Environment (PXE)**: PXE is a network boot protocol that allows a computer to boot from a network server.

  - **What is PXE and how is it used?**
    - PXE (Preboot eXecution Environment) is a network boot protocol that allows a computer to boot from a network server. It is commonly used for deploying operating systems and software to multiple computers over a network.

- **Booting from Universal Serial Bus (USB)**: Booting from USB allows a system to start up using a bootable USB drive.

  - **How do you boot a system from a USB drive?**
    - To boot a system from a USB drive, you need to create a bootable USB drive with an operating system image, insert it into the USB port, and configure the BIOS/UEFI to prioritize booting from the USB drive.

- **Booting from ISO**: Booting from ISO allows a system to start up using an ISO image file, typically written to a CD/DVD or USB drive.

  - **What is required to boot a system from an ISO image?**
    - To boot a system from an ISO image, you need to write the ISO image to a CD/DVD or create a bootable USB drive with the ISO image, and configure the BIOS/UEFI to boot from the CD/DVD or USB drive.

- **Commands**: Some common commands used in managing the boot process in Linux include `mkinitrd`, `grub2-install`, `grub2-mkconfig`, `grub2-update`, and `dracut`. These commands are used for creating initial RAM disks, installing and configuring the GRUB bootloader, and generating boot configuration files.

  - **`mkinitrd`**: stands for "make initial RAM disk" and is used to create an initial RAM disk (initrd) image, which is a temporary root filesystem used by the Linux kernel during the boot process to load necessary drivers and mount the real root filesystem.

    - **What is the purpose of the `mkinitrd` command?**
      - The `mkinitrd` command creates an initial RAM disk (initrd) image, which the Linux kernel uses during the boot process to load necessary drivers and mount the real root filesystem.

  - **`grub2-install`**: is a command to install the GRUB2 bootloader on the system. It copies the necessary files to the designated boot partition and makes the system bootable with GRUB2.

    - **What does the `grub2-install` command do?**
      - The `grub2-install` command installs the GRUB2 bootloader on the system, making the system bootable with GRUB2 by copying necessary files to the designated boot partition.

  - **`grub2-mkconfig`**: stands for "GRUB2 make configuration" and is used to generate a new GRUB2 configuration file (`grub.cfg`) based on the current system configuration and available kernels. It detects operating systems and updates the boot menu.

    - **How is the `grub2-mkconfig` command used in the boot process?**
      - The `grub2-mkconfig` command generates a new GRUB2 configuration file (`grub.cfg`), updating the boot menu based on the current system configuration and available kernels.

  - **`grub2-update`**: `grub2-update` is a command to update the GRUB2 bootloader configuration. It re-runs `grub2-mkconfig` to regenerate the GRUB configuration file with any new changes to the system.

    - **What is the function of `grub2-update`?**
      - The `grub2-update` command updates the GRUB2 bootloader configuration by re-running `grub2-mkconfig` to regenerate the GRUB configuration file with any new system changes.

  - **`dracut`**: `dracut` is a tool for creating initramfs images, similar to `mkinitrd`. It generates a minimal, modular initramfs that the Linux kernel uses to load necessary drivers and mount the root filesystem during boot.

    - **What is `dracut` and how is it used?**
      - `dracut` is a tool for creating initramfs images, generating a minimal, modular initramfs that the Linux kernel uses during boot to load necessary drivers and mount the root filesystem.

**Boot Process Diagram**:

```mermaid
graph LR
    A["1. Power On"] --> B
    B --> C
    C --> D
    D --> E
    E --> F
    F --> G
    G --> H
    H --> I
    I --> J["10. Login Prompt"]

    subgraph "BIOS/UEFI"
        direction TB
        B["2. BIOS/UEFI Initialization"]
        C["3. POST"]
    end

    subgraph "Bootloader"
        direction TB
        D["4. Bootloader (GRUB2)"]
        E["5. Kernel (vmlinuz)"]
        F["6. initrd.img"]
    end

    subgraph "Kernel Initialization"
        direction TB
        G["7. Systemd/Init"]
        H["8. Mount Root Filesystem"]
        I["9. User Space Initialization"]
    end


```

1. **Power On**: The system is powered on, and the initial hardware components receive power and begin to initialize.
2. **BIOS/UEFI Initialization**: The Basic Input/Output System (BIOS) or Unified Extensible Firmware Interface (UEFI) firmware initializes system hardware, performs system integrity checks, and prepares the system for booting.
3. **POST (Power-On Self Test)**: The BIOS/UEFI runs a series of diagnostic tests to ensure all essential hardware components (CPU, RAM, disk controllers, etc.) are functioning correctly. If any critical issues are detected, the boot process is halted, and error codes or messages are displayed.
4. **Bootloader (GRUB2)**: The BIOS/UEFI hands over control to the bootloader, typically GRUB2 in modern Linux systems. GRUB2 is responsible for loading the operating system. It presents a menu to the user for selecting an operating system or kernel to boot.
5. **Kernel (vmlinuz)**: The selected Linux kernel (`vmlinuz`) is loaded into memory. The kernel is responsible for managing system resources and hardware interactions.
6. **initrd.img**: The initial RAM disk image (`initrd.img`) is loaded. This temporary root filesystem contains necessary drivers and scripts needed to initialize the hardware and mount the real root filesystem.
7. **Systemd/Init**: The init system (commonly `systemd` on modern Linux distributions) is executed. It is the first process started by the kernel and is responsible for initializing the user space and managing system services.
8. **Mount Root Filesystem**: The real root filesystem is mounted, replacing the initial RAM disk. This step involves mounting the partitions defined in the system's fstab configuration.
9. **User Space Initialization**: System services and daemons are started according to the init system's configuration. This includes network services, graphical interfaces, and other background services.
10. **Login Prompt**: The system reaches the login prompt stage, where users can log in to start using the system. This could be a graphical login screen (display manager) or a text-based login prompt (TTY).

### 1.1.3 Kernel Panic

A kernel panic is an action taken by an operating system upon detecting an internal fatal error from which it cannot safely recover. The term is primarily used in Unix and Unix-like operating systems, such as Linux and macOS.

- **Causes of Kernel Panic**:

  - **Hardware Issues**: Faulty RAM, CPU, or other hardware components can trigger a kernel panic.
  - **Software Bugs**: Errors in the operating system kernel or kernel modules, such as device drivers, can cause a kernel panic.
  - **Corrupted Filesystems**: Filesystem corruption can lead to a kernel panic when the system tries to access corrupted files or directories.
  - **Misconfigured System Settings**: Incorrect configurations, such as bootloader settings or kernel parameters, can result in a kernel panic.

- **Symptoms**:

  - The system becomes unresponsive.
  - A screen displaying an error message or a stack trace.
  - On some systems, an LED indicator may blink in a specific pattern to signal a kernel panic.

- **Kernel Panic Message**:

  ```yml
  Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
  CPU: 0 PID: 1 Comm: swapper/0 Not tainted 4.15.0-20-generic #21-Ubuntu
  Hardware name: Example Manufacturer ExampleModel/ExampleBoard, BIOS 1.0.0 01/01/2020
  Call Trace:
   dump_stack+0x63/0x8b
   panic+0xe4/0x252
   mount_block_root+0x26d/0x2da
   mount_root+0x12a/0x136
   prepare_namespace+0x13d/0x191
   kernel_init_freeable+0x23e/0x261
   ? rest_init+0xb0/0xb0
   kernel_init+0xe/0x100
   ret_from_fork+0x35/0x40
  RIP: 0010:ret_from_fork+0x35/0x40
  RSP: 0000:ffffffff81803e58 EFLAGS: 00010246
  RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000
  RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000000000000000
  RBP: ffff88007d703e38 R08: 0000000000000000 R09: 0000000000000000
  R10: 0000000000000000 R11: 0000000000000000 R12: ffff88007d703e80
  R13: ffff88007d703e80 R14: ffff88007d703e88 R15: 0000000000000000
  FS:  0000000000000000(0000) GS:ffff88007d600000(0000) knlGS:0000000000000000
  CS:  0010 DS: 0000 ES: 0000 CR0: 80050033 CR2: 0000000000000000 CR3: 0000000001a09000 CR4: 00000000000006f0
  ```

  - The kernel panic message usually includes:
  - The type of panic (e.g., "kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)").
  - A call trace or stack trace that shows the sequence of function calls leading to the panic.
  - Registers and memory addresses to help diagnose the problem.

- **Handling Kernel Panic**:

  - **Reboot the System**: Often, the only way to recover from a kernel panic is to reboot the system.
  - **Check Hardware**: Verify that all hardware components are functioning correctly and are properly seated. Run hardware diagnostics if available.
  - **Update Software**: Ensure that the operating system, kernel, and all drivers are up-to-date to avoid known bugs.
  - **Check System Logs**: Review system logs, especially `/var/log/kern.log` or `/var/log/syslog`, for additional details about the kernel panic.
  - **Safe Mode/Single-User Mode**: Boot the system into safe mode or single-user mode to perform troubleshooting and repair tasks.
  - **Remove Recent Changes**: If the panic started after recent changes, such as new hardware or software installation, undo those changes to see if the problem resolves.

- **Preventing Kernel Panic**:

  - **Regular System Updates**: Keep the system updated with the latest patches and updates.
  - **Stable Hardware**: Use reliable and compatible hardware components.
  - **Backup and Recovery Plans**: Maintain regular backups and have a recovery plan in place to minimize downtime in case of a kernel panic.
  - **Proper System Configuration**: Ensure system settings and configurations are correct and follow best practices.

- **Possible Interview Questions and Answers**:
  - **What is a kernel panic?**
    - A kernel panic is an action taken by an operating system upon detecting an internal fatal error from which it cannot safely recover.
  - **What are some common causes of a kernel panic?**
    - Common causes include hardware issues, software bugs, corrupted filesystems, and misconfigured system settings.
  - **How can you diagnose and handle a kernel panic?**
    - Diagnose by checking system logs and error messages. Handle by rebooting the system, checking hardware, updating software, reviewing logs, booting into safe mode, and removing recent changes.
  - **How can kernel panics be prevented?**
    - Prevent by keeping the system updated, using stable hardware, maintaining backups, having a recovery plan, and ensuring proper system configurations.

### 1.1.4 Device types in /dev

- **Block devices**: Block devices are hardware devices that read and write data in fixed-sized blocks, typically 512 bytes or more. Examples include hard drives, SSDs, and optical drives. Block devices allow random access to fixed-size blocks of data, making them suitable for storage devices. They are represented by device files in the `/dev` directory, such as `/dev/sda` for a SATA hard drive or `/dev/nvme0n1` for an NVMe SSD.

  - **What are block devices and how do they function?**

    - Block devices read and write data in fixed-sized blocks and allow random access to these blocks. Examples include hard drives and SSDs.
    - **Can you provide an example of a block device file?**
      - An example is `/dev/sda`, which represents a SATA hard drive.

- **Character devices**: Character devices are hardware devices that transmit data one character at a time. They provide a sequential stream of data, making them suitable for devices like keyboards, mice, and serial ports. Character devices are represented by device files in the `/dev` directory, such as `/dev/ttyS0` for a serial port.

  - **What are character devices and how do they function?**

    - Character devices transmit data one character at a time and provide a sequential stream of data. Examples include keyboards and serial ports.
    - **Can you provide an example of a character device file?**
      - An example is `/dev/ttyS0`, which represents a serial port.

- **Special character devices**: Special character devices are a subset of character devices that serve specific functions. They include:

  - **`/dev/null`**: A special file that discards all data written to it and provides no data when read. It is often used to discard unwanted output or as a placeholder in scripts.

    - **What is the purpose of `/dev/null`?**
      - `/dev/null` discards all data written to it and provides no data when read. It is used to discard unwanted output.

  - **`/dev/zero`**: A special file that provides as many null (zero) bytes as are read from it. It is often used to create empty files or initialize storage with zeroes.

    - **What is the purpose of `/dev/zero`?**
      - `/dev/zero` provides null bytes when read, and it is used to create empty files or initialize storage with zeroes.

  - **`/dev/urandom`**: A special file that provides random data generated by the kernel's random number generator. It is used for cryptographic purposes, testing, and other applications requiring random data.
    - **What is the purpose of `/dev/urandom`?**
      - `/dev/urandom` provides random data generated by the kernel's random number generator and is used for cryptographic purposes and testing.

### 1.1.5 Basic package compilation from source

- **`./configure`**: The `./configure` script is used to prepare the source code for compilation. It checks for system dependencies, sets up necessary environment variables, and generates the Makefile, which contains the instructions for building the software. The script allows customization of the build process by accepting various options and parameters.

  - **What is the purpose of the `./configure` script in the compilation process?**
    - The `./configure` script prepares the source code for compilation by checking for system dependencies, setting up environment variables, and generating the Makefile.
  - **How can you customize the build process using `./configure`?**
    - You can customize the build process by passing options and parameters to `./configure`, such as `--prefix` to specify the installation directory.

- **`make`**: The `make` command reads the Makefile generated by `./configure` and compiles the source code into executable binaries. It automates the build process by following the instructions in the Makefile, handling dependencies, and optimizing the compilation steps.

  - **What does the `make` command do in the package compilation process?**
    - The `make` command compiles the source code into executable binaries by following the instructions in the Makefile.
  - **Why is `make` important for automating the build process?**
    - `make` automates the build process by handling dependencies, optimizing compilation steps, and ensuring the correct order of operations based on the Makefile.

- **`make install`**: The `make install` command installs the compiled binaries and associated files into the system's designated directories. It follows the instructions in the Makefile to copy files to appropriate locations, set permissions, and create necessary directories.

  - **What is the role of the `make install` command in the package compilation process?**
    - The `make install` command installs the compiled binaries and associated files into the system's designated directories according to the Makefile's instructions.
  - **What precautions should you take before running `make install`?**
    - Before running `make install`, ensure you have proper permissions (usually root or superuser) and review the installation paths to avoid overwriting critical system files.

Here is a step-by-step example of compiling and installing a package from source:

1. **Download the Source Code**:

   ```sh
   wget http://example.com/package.tar.gz
   tar -xzf package.tar.gz
   cd package
   ```

2. **Run `./configure`**:

   ```
   ./configure --prefix=/usr/local
   ```

   - This command configures the source code, checking for dependencies and generating the Makefile.

3. **Run `make`**:

   ```sh
   make
   ```

   - This command compiles the source code into executable binaries.

4. **Run `make install`**:

   ```
   sudo make install
   ```

   - This command installs the compiled binaries and associated files into the system's directories.

### 1.1.6 Storage concepts

- **File storage**: File storage is a storage system where data is stored in files and directories. It uses a hierarchical structure, similar to a traditional file system on a computer. This type of storage is common for network-attached storage (NAS) systems and is ideal for storing a large number of files, such as documents, images, and videos.

  - **What is file storage?**
    - File storage is a storage system where data is organized into files and directories in a hierarchical structure.
  - **What are common use cases for file storage?**
    - Common use cases include network-attached storage (NAS) systems for storing documents, images, and videos.

- **Block storage**: Block storage is a storage system where data is divided into fixed-size blocks. Each block can be individually accessed and managed. This type of storage is commonly used for high-performance applications, such as databases and virtual machines, because it allows low-latency access to data.

  - **What is block storage?**
    - Block storage is a storage system where data is divided into fixed-size blocks, each of which can be individually accessed and managed.
  - **What are common use cases for block storage?**
    - Common use cases include high-performance applications like databases and virtual machines.

- **Object storage**: Object storage is a storage architecture that manages data as objects, each with a unique identifier, metadata, and data. It is designed for scalability and is commonly used for storing unstructured data, such as backups, media files, and large datasets.

  - **What is object storage?**
    - Object storage is a storage architecture that manages data as objects, each with a unique identifier, metadata, and data.
  - **What are common use cases for object storage?**
    - Common use cases include storing unstructured data like backups, media files, and large datasets.

- **Partition types**:

  - **Master boot record (MBR)**: MBR is a partitioning scheme that uses a special boot sector located at the beginning of a storage device. It supports up to four primary partitions and has a maximum disk size limit of 2TB.

    - **What is the Master Boot Record (MBR)?**
      - The Master Boot Record (MBR) is a partitioning scheme that uses a special boot sector at the beginning of a storage device, supporting up to four primary partitions and a maximum disk size of 2TB.

  - **GUID (globally unique identifier) Partition Table (GPT)**: GPT is a modern partitioning scheme that supports a virtually unlimited number of partitions and larger disk sizes than MBR. It stores multiple copies of the partition table for redundancy and includes CRC32 checksums for integrity verification.

    - **What is the GUID Partition Table (GPT)?**
      - The GUID Partition Table (GPT) is a modern partitioning scheme that supports a virtually unlimited number of partitions and larger disk sizes, with redundancy and integrity verification features.

- **Filesystem in Userspace (FUSE)**: FUSE is a software interface that allows the creation of filesystems in user space rather than kernel space. This enables non-privileged users to create and manage their own filesystems, making it easier to develop and use custom filesystems.

  - **What is FUSE and why is it useful?**
    - FUSE (Filesystem in Userspace) is a software interface that allows the creation of filesystems in user space, enabling non-privileged users to create and manage custom filesystems.
  - **Can you provide an example of a filesystem that uses FUSE?**
    - An example is `sshfs`, which allows you to mount remote directories over SSH as local filesystems.

- **Redundant Array of Independent (or Inexpensive) Disks (RAID) levels**:

  - **Striping (RAID 0)**: RAID 0 splits data across multiple disks, improving performance by allowing parallel access to data. However, it offers no redundancy, so data loss occurs if any disk fails.

    - **What is RAID 0 and what are its advantages and disadvantages?**
      - RAID 0 (striping) splits data across multiple disks, improving performance but offering no redundancy, leading to data loss if any disk fails.

  - **Mirroring (RAID 1)**: RAID 1 duplicates data across multiple disks, providing redundancy and improved read performance. If one disk fails, the data can be read from the other disk.

    - **What is RAID 1 and what are its advantages and disadvantages?**
      - RAID 1 (mirroring) duplicates data across multiple disks, providing redundancy and improved read performance, but it requires twice the storage capacity.

  - **Parity (RAID 5, RAID 6)**: RAID levels with parity, such as RAID 5 and RAID 6, distribute data and parity information across multiple disks. RAID 5 can tolerate a single disk failure, while RAID 6 can tolerate two disk failures.

    - **What is RAID 5 and how does it differ from RAID 6?**
      - RAID 5 uses distributed parity to tolerate a single disk failure, while RAID 6 uses double parity to tolerate two disk failures, providing higher redundancy at the cost of additional storage overhead.

### 1.1.7 Listing hardware information

- **`lspci`**: The `lspci` command lists all PCI (Peripheral Component Interconnect) devices on the system. It provides detailed information about each PCI device, including the device name, vendor, and device ID. This command is useful for identifying hardware components such as network cards, graphics cards, and other PCI-based devices.

  - **What does the `lspci` command do?**
    - The `lspci` command lists all PCI devices on the system, providing detailed information about each device.
  - **How can you use `lspci` to find information about your graphics card?**
    - Running `lspci | grep -i vga` will filter the output to show information about the graphics card.

- **`lsusb`**: The `lsusb` command lists all USB (Universal Serial Bus) devices connected to the system. It provides details about each USB device, including the device ID, vendor, and product ID. This command is useful for identifying connected USB peripherals such as keyboards, mice, storage devices, and more.

  - **What does the `lsusb` command do?**
    - The `lsusb` command lists all USB devices connected to the system, providing details about each device.
  - **How can you use `lsusb` to find information about a connected USB storage device?**
    - Running `lsusb | grep -i storage` will filter the output to show information about USB storage devices.

- **`dmidecode`**: The `dmidecode` command retrieves hardware information from the system's DMI (Desktop Management Interface) table. It provides detailed information about the system's hardware components, including BIOS version, motherboard model, CPU, memory, and more. This command is useful for obtaining comprehensive hardware details directly from the system firmware.

  - **What does the `dmidecode` command do?**
    - The `dmidecode` command retrieves hardware information from the system's DMI table, providing detailed information about the system's hardware components.
  - **How can you use `dmidecode` to find information about the system's BIOS?**
    - Running `sudo dmidecode -t bios` will display detailed information about the system's BIOS.

Examples of Command Usage:

1. **Listing PCI Devices with `lspci`**:

   ```sh
   lspci
   ```

- This command lists all PCI devices on the system.

2.  **Listing USB Devices with `lsusb`**:

    ```
    lsusb
    ```

    - This command lists all USB devices connected to the system.

3.  **Retrieving BIOS Information with `dmidecode`**:

    ```
    sudo dmidecode -t bios
    ```

    - This command retrieves detailed information about the system's BIOS from the DMI table.

## 1.2 Given a scenario, manage files and directories.

- **File editing**

  - `sed`
  - `awk`
  - `printf`
  - `nano`
  - `vi(m)`

- **File compression, archiving, and backup**

  - `gzip`
  - `bzip2`
  - `zip`
  - `tar`
  - `xz`
  - `cpio`
  - `dd`

- **File metadata**

  - `stat`
  - `file`

- **Soft and hard links**

- **Copying files between systems**

  - `rsync`
  - `scp`
  - `nc`

- **File and directory operations**
  - `mv`
  - `cp`
  - `mkdir`
  - `rmdir`
  - `ls`
  - `pwd`
  - `rm`
  - `cd`
  - `.`
  - `..`
  - `~`
  - `tree`
  - `cat`
  - `touch`

## 1.3 Given a scenario, configure and manage storage using the appropriate tools.

- **Disk partitioning**

  - Commands
    - `fdisk`
    - `parted`
    - `partprobe`

- **Mounting local and remote devices**

  - `systemd.mount`
  - `/etc/fstab`
  - `mount`
  - Linux Unified Key Setup (LUKS)
  - External devices

- **Filesystem management**

  - XFS tools
  - Ext4 tools
  - Btrfs tools

- **Monitoring storage space and disk usage**

  - `df`
  - `du`

- **Creating and modifying volumes using Logical Volume Manager (LVM)**

  - Commands
    - `pvs`
    - `vgs`
    - `lvs`
    - `lvchange`
    - `lvcreate`
    - `vgcreate`
    - `lvresize`
    - `pvcreate`
    - `vgextend`

- **Inspecting RAID implementations**

  - `mdadm`
  - `/proc/mdstat`

- **Storage area network (SAN)/network-attached storage (NAS)**

  - `multipathd`
  - Network filesystems
    - Network File System (NFS)
    - Server Message Block (SMB)/Common Internet File System (CIFS)

- **Storage hardware**
  - `lsscsi`
  - `lsblk`
  - `blkid`
  - `fcstat`

## 1.4 Given a scenario, configure and use the appropriate processes and services.

- **System services**

  - `systemctl`
    - stop
    - start
    - restart
    - status
    - enable
    - disable
    - mask

- **Scheduling services**

  - `cron`
  - `crontab`
  - `at`

- **Process management**
  - Kill signals
    - `SIGTERM`
    - `SIGKILL`
    - `SIGHUP`
  - Listing processes and open files
    - `top`
    - `ps`
    - `lsof`
    - `htop`
  - Setting priorities
    - `nice`
    - `renice`
  - Process states
    - Zombie
    - Sleeping
    - Running
    - Stopped
  - Job control
    - `bg`
    - `fg`
    - `jobs`
    - `Ctrl+Z`
    - `Ctrl+C`
    - `Ctrl+D`
  - `pgrep`
  - `pkill`
  - `pidof`

## 1.5 Given a scenario, use the appropriate networking tools or configuration files.

- **Interface management**

  - iproute2 tools
    - `ip`
    - `ss`
  - NetworkManager
    - `nmcli`
  - net-tools
    - `ifconfig`
    - `ifcfg`
    - `hostname`
    - `arp`
    - `route`
  - `/etc/sysconfig/network-scripts/`

- **Name resolution**

  - `nsswitch`
  - `/etc/resolv.conf`
  - systemd
    - `hostnamectl`
    - `resolvectl`
  - Bind-utils
    - `dig`
    - `nslookup`
    - `host`
  - WHOIS

- **Network monitoring**

  - `tcpdump`
  - `wireshark`/`tshark`
  - `netstat`
  - `traceroute`
  - `ping`
  - `mtr`

- **Remote networking tools**
  - Secure Shell (SSH)
  - `cURL`
  - `wget`
  - `nc`
  - `rsync`
  - Secure Copy Protocol (SCP)
  - SSH File Transfer Protocol (SFTP)

## 1.6 Given a scenario, build and install software.

- **Package management**

  - `DNF`
  - `YUM`
  - `APT`
  - `RPM`
  - `dpkg`
  - `ZYpp`

- **Sandboxed applications**

  - `snapd`
  - `Flatpak`
  - `AppImage`

- **System updates**
  - Kernel updates
  - Package updates

## 1.7 Given a scenario, manage software configurations.

- **Updating configuration files**

  - Procedures
    - Restart service
    - Reload service
  - `.rpmnew`
  - `.rpmsave`
  - Repository configuration files
    - `/etc/apt.conf`
    - `/etc/yum.conf`
    - `/etc/dnf/dnf.conf`
    - `/etc/yum.repo.d`
    - `/etc/apt/sources.list.d`

- **Configure kernel options**

  - Parameters
    - `sysctl`
    - `/etc/sysctl.conf`
  - Modules
    - `lsmod`
    - `imsmod`
    - `rmmod`
    - `insmod`
    - `modprobe`
    - `modinfo`

- **Configure common system services**

  - SSH
  - Network Time Protocol (NTP)
  - Syslog
  - chrony

- **Localization**
  - `timedatectl`
  - `localectl`
